<html>
	<head>
		<link rel="StyleSheet" href="../css/tester.css">
		<style>
			.static-target {
				background-color: #000;
			}
			.scene-world {
				border: 1px dotted #000;
			}
		</style>
		<script src="../lib/curl.js"></script>
		<script>
			// some <script data-main=""> semantics to reduce this boilerplate 
			console.log("requiring qtower");
			require({
				baseUrl: '..',
				paths: {
					assets: '../assets'
				}
			}, [
				'lib/lang',
				'lib/compose',
				'lib/vector',
				'lib/entity',
				'game/npc',
				'game/Scene',
				'lib/Loopable',
				'game/config'
			], function(lang, Compose, vector, ent, npc, Scene, Loopable, config){

				var after = Compose.after, 
					before = Compose.before, 
					from = Compose.from;

				var scene = window.scratchScene = Compose.create(function(){
					console.log("scratchScene scene ctor");
				}, Scene, Loopable,
				{
					id: "scratchScene",
					className: "scene scene-world",

					enter: after(function(){
						console.log("entering testThings scene");
						this.startLoop();
						// run for just 10 seconds
						this.endTime = this.startTime + 10000;
					}),

					redraw: function(count){
						this.raiseEvent("redraw");
					},

					update: function(frameCount){
						this.timestamp = (new Date()).getTime();
						// if(this.timestamp >= this.endTime) {
						// 	console.log("stopping at: ", this.timestamp);
						// 	return this.stopLoop();
						// }

						// update logic: 
						// process rules
						// call update on all active entities, 
						this.raiseEvent("update");
					},
					render: from(Scene),
					exit: before(function(){
						console.log("Scene exit, isRunning=false, clearing interval: ", this._intervalId);
						this.stopLoop();
					}),
					load: from(Scene),
					unload: from(Scene),

					prepare: function(){
						var config = this.config,
							bounds = {
								x: config.get("mapWidth"), 
								y: config.get("mapHeight")
							}, 
							thing = null, 
							entities = this.entities
						;
						console.log("bounds: ", bounds);
						
						entities.push( this._makeThing(bounds) );
						
						// TODO: pass entity the scene so they can register their own events?
						// lang.forEach(entities, function(thing){
						// 	// hook up this entity to the scene update events
						// }, this);

						this.prepared = true;
					}, 
					_makeThing: function(bounds){
						var thing = new npc.MovingThing({
							id: "thing",
							scene: this, // give the entity a reference to the scene
							width: 50,
							height: 50,
							bounds: bounds,
							frameY: 1,
							x: Math.random() * (bounds.x - 50),
							y: Math.random() * (bounds.y - 50),
						});
						console.log("made thing with x, y: ", thing.x, thing.y);
						return thing;
					}
				});
				window.onload = function(){

					// var itv = setInterval(function(){
					// 	thing.update();
					// }, 1000/60);
					// 
					gameNode = document.getElementById("playarea");
					gameNode.style.width = config.get("mapWidth") + "px";
					gameNode.style.height = config.get("mapHeight") + "px";

					scratchScene.enter();
					
					sceneNode = scratchScene.node;
					sceneNode.style.width = config.get("mapWidth") + "px";
					sceneNode.style.height = config.get("mapHeight") + "px";
				
					
					document.addEventListener("click", function(event){
						//X distance to target, Y distance to target, and Euclidean distance
						scratchScene.raiseEvent("newtarget", {
							x: event.pageX, 
							y: event.pageY
						});
					});

					scratchScene.addEventListener("newtarget", function(evt){
						console.log("newtarget event: ", evt);
						var spot = new npc.Barrier({
							id: "barrier_" +(new Date()).getTime,
							x: evt.x - 5,
							y: evt.y -5,
							scene: scratchScene,
							className: "sprite static-spot",
							_firstUpdate: true
						});
						spot.render(scratchScene.node);
						scratchScene.entities.push(spot);
					});
					scratchScene.addEventListener("update", function(){
						// console.log("scene update");
					});
				}
			}); 
		</script>
	</head>
	<body style="margin:0;padding:0;">
		<div id="playarea" style="height: 300px; margin-right:10px;"></div>
	</body>
</html>

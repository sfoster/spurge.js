<html>
	<head>
		<link rel="stylesheet" type="text/css" href="../css/tester.css"/>
		<style>
		.point {
			position: absolute;
			top: 0;
			left: 0;
			z-index: 20;
		}
		</style>
		<script src="../lib/curl.js"></script>
		<script>
			// some <script data-main=""> semantics to reduce this boilerplate?
			require = curl;
			require({
				baseUrl: '..',
				paths: {
					assets: '../assets'
				}
			}, [
				'lib/lang',
				'lib/compose',
				'lib/Graph',
				'lib/promise',
				// 'lib/state',
				'lib/Evented',
				'lib/loop', 
				'lib/rendering'
			], function(lang, Compose, Graph, Promise, Evented, loop, Renderable){

				var after = Compose.after, 
					before = Compose.before, 
					from = Compose.from;

				console.log("define window.game");
				var Game = Compose(Graph, function(){
					console.log("game ctor");
					var defaultSequence = [
						"loadContent", 
						"prepare",
						"activate"
					];
					var self = this;
					// 
					this.start = function(){
						console.log("Game start");
						// any of the steps in start could be async
						this.sequence = new Promise.Sequence(
							defaultSequence.map(function(name){
								return lang.bind(self, name)
							})
						);
						this.sequence.next();
					};
				}, {
					init: after(function(){
						console.log("Game init");
						this.clock = new loop.Loop({
							familyName: "universe",
							id: "clock",
							update: lang.bind(this, this.update),
							redraw: lang.bind(this, this.render),
						});
					}),
					prepare: function(){
						console.log("Game prepare");
						// assets are loaded, now is a good time 
						// to create components and entities & populate the graph 

						// move to rootComponent's initialRender
						
						this.attachTo(
							{ id: "physics" }
						);
						this.attachTo(
							{ id: "path-finding" }
						);

						console.log("adding creep");
						this.attachTo(new Creep({
							graph: this,
							id: "creep1"
						}));
						console.log("/adding creep");
						
					},
					loadContent: function(){
						console.log("loading assets");
					},
					activate: function(){
						console.log("start clock if we have one");
						console.log("kick off the update cycle");
						this.clock.startLoop();
					},
					update: function(){
						var now = this.timestamp = +new Date;

						// walk the graph
						this.traverse(function(c){
							if("function" == typeof c.update){
								c.update(now, stack);
							}
						});
					},
					render: function(){
						var c = this.rootComponent; 
						c.render && c.render();
					},
					shutdown: function(){
						this.clock.stopLoop();
					}
				});

				var game = window.game = new Game({
					Component: Graph.Component,
					ComponentCollection: Graph.ComponentCollection,
				});
				
				console.log("defining game.Entity");
				game.Entity = Compose(game.Component, Renderable, {
					update: from(game.Component, "update"),
					initialRender: from(Renderable, "render"),
					render: from(Renderable, "update")
				});
				console.log("/defining game.Entity");

				console.log("defining renderer component, to extend game.Component: ", game.Component);
				var RenderManager = Compose.create(game.Component, {
					graph: game,
					onAttach: function(renderRoot){
						// the renderer has been attached to a component
						renderRoot.renderQueue = [];
						// the renderer provides a render method for the components
						// it is attached to
						renderRoot.render = function(){
							// the renderQueue is assembled each update
							// all "dirty" components the need re-rendering get added
							// the queue is consumed
							
							// TODO: how do they get added? 
							// does every renderable component have the renderer attached? 
							// in which case, why the queue? Why not just loop back over the graph 
							// and call render on anything that has a render method
							
							// Or, if we have one renderer, components that need rendering do...what? 

							// the renderQueue is maintained by the renderer
							// 	it adds components to it when it is attached? hmm.
							// 	we already have an attachList that serves that function
							
							// it makes sense to have a single render queue
							// 	we can only render one component at a time, and they need to be done in sequence
							// 	does a component put itself on the queue with an event? schedule-render
							// 	that would let stuff render itself once, 
							// 	then stay unchanged (in a DOM renderer), only re-rendering when some change occurs
							// if components have a dirty() method, we can lookup dirtiness propertyies to see if that implies a renderable change
							// if so, they get pushed onto the renderQ. 
							
							
							// an event seems the most likely impl. 
							// as the component could be at any level in the heirarchy
							// the component wants to communicate something, to a renderer which it didn't not itself create
							var renderQ = this.renderQueue, 
								ent;
							while((ent = renderQ.pop())){
								ent.render();
							};
							// this.timeNode.innerHTML = this.timestamp;
							ent = null;
						};
						// this.timeNode = document.getElementById("timestamp");
					},
					onDetach: function(renderRoot){
						// the renderer comp is being detached 
						if(renderRoot.renderQueue){
							renderRoot.renderQueue = null;
						}
						delete renderRoot.renderQueue;
					},
					update: function(){
						// when the rendering component is updated, what happens? 
					}
				}, function(){
						if(!this.graph) {
							throw new Error("Renderer created without a graph property");
						}
						if(!this.stageNode) {
							if(this.stageId) {
								this.stageNode = document.getElementById("playarea");
							} else {
								throw new Error("Renderer created without a stageNode or stageId");
							}
						}
						this.renderQueue = [];
					}
				);

				var sineWave = null;
				var Creep = Compose(game.Entity, {
					x: 0, 
					y: 0,
					type: "creep",
					init: after(function(){
						console.log("Creep init");
						var node = this.domNode = document.createElement("div");
						node.className = "static-spot point";
						game.stageNode.appendChild(node);
						
						// add a behavior
						this.attachComponent(sineWave || (sineWave = new SineWave({
							graph: game
						})));
					}),
					update: function(){
						// this.domNode.style.left = this.x +"px";
						// this.domNode.style.top = (90+this.y) +"px";
						// console.log("Creep render: ", this.x, this.y, this.domNode.style.cssText);
					}
				});
				var Creeplet = Compose(Creep, {
					init: function(){
						console.log("Creep init");
						var node = this.domNode = document.createElement("div");
						node.className = "static-spot point";
						game.stageNode.appendChild(node);
					},
				})
				
				var SineWave = Compose(game.Component, {
					y: 0,
					x: 0,
					type: "sine-wave",
					update: function(timestamp, stack){
						var y = this.y,
							x = this.x,
							parent = stack.get("parent");
						parent.x = x;
						parent.y = 50 * Math.sin(y);
						p
						this.y = y >= 100 ? 0 : y+0.1;
						this.x = x >= 800 ? 0 : x+4;
						// console.log("sineWave: ", this._parent.x, this._parent.y);
					}
				})

				game.start();
				setTimeout(function(){
					game.shutdown()
				}, 12000);
			}); 
		</script>
	</head>
	<body style="margin:0;padding:0;">
		<div id="playarea" style="height: 200px; margin-right:10px;">
			<div id="timestamp"></div>
		</div>
		<input type="button" value="start" onclick="game.start();">
		&nbsp;
		<input type="button" value="stop" onclick="game.shutdown('ended');">
		&nbsp;
		<input type="button" value="menu mode" onclick="game.enterState('menu');">
	</body>
</html>
